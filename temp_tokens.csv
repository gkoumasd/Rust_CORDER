# [doc = " # safety "] # [doc = " callers must ensure that the given length matches given value length ."] fn write data (value : & [u 8] , buf : * mut u 8 , len : usize) { debug assert eq ! (value . len () , len) ; copy nonoverlapping (value . as ptr () , buf , len) ; }
# [doc = " # safety "] # [doc = " caller must ensure the buffer has the correct size and alignment ."] # [inline] fn cast slice (buf : & mut [u 8]) -> & mut [u 64] { debug assert ! (buf . len () . trailing zeros () >= 3) ; debug assert ! ((buf . as ptr () as usize) . trailing zeros () >= 3) ; slice :: from raw parts mut (buf . as mut ptr () as * mut u 64 , buf . len () >> 3) }
# [doc = " shift `a` to the left by two bytes (removing its two most significant "] # [doc = " bytes), and concatenate it with the the two most significant bytes of `b`."] # [target feature (enable = " avx 2 ")] pub fn alignr 256 14 (a : m 256 i , b : m 256 i) -> m 256 i { let v = mm 256 permute 2 x 128 si 256 (b , a , 0 x 21) ; mm 256 alignr epi 8 (a , v , 14) }
# [doc = " shift `a` to the left by one byte (removing its most significant byte), and "] # [doc = " concatenate it with the the most significant byte of `b`."] # [target feature (enable = " avx 2 ")] pub fn alignr 256 15 (a : m 256 i , b : m 256 i) -> m 256 i { let v = mm 256 permute 2 x 128 si 256 (b , a , 0 x 21) ; mm 256 alignr epi 8 (a , v , 15) }
# [doc = " returns true if and only if all bits in the given 128-bit vector are 0 ."] # [target feature (enable = " ssse 3 ")] pub fn is all zeroes 128 (a : m 128 i) -> bool { let cmp = mm cmpeq epi 8 (a , zeroes 128 ()) ; mm movemask epi 8 (cmp) as u 32 == 0 x ffff }
# [doc = " returns true if and only if all bits in the given 256-bit vector are 0 ."] # [target feature (enable = " avx 2 ")] pub fn is all zeroes 256 (a : m 256 i) -> bool { let cmp = mm 256 cmpeq epi 8 (a , zeroes 256 ()) ; mm 256 movemask epi 8 (cmp) as u 32 == 0 x ffffffff }
# [doc = " load a 128-bit vector from slice at the given position . the slice does "] # [doc = " not need to be unaligned ."] # [doc = ""] # [doc = " since this code assumes little-endian (there is no big-endian x 86), the "] # [doc = " bytes starting in `slice[at ..]` will be at the least significant bits of "] # [doc = " the returned vector . this is important for the surrounding code, since for "] # [doc = " example, shifting the resulting vector right is equivalent to logically "] # [doc = " shifting the bytes in `slice` left ."] # [target feature (enable = " sse 2 ")] pub fn loadu 128 (slice : & [u 8] , at : usize) -> m 128 i { let ptr = slice . get unchecked (at ..) . as ptr () ; mm loadu si 128 (ptr as * const u 8 as * const m 128 i) }
# [doc = " load a 256-bit vector from slice at the given position . the slice does "] # [doc = " not need to be unaligned ."] # [doc = ""] # [doc = " since this code assumes little-endian (there is no big-endian x 86), the "] # [doc = " bytes starting in `slice[at ..]` will be at the least significant bits of "] # [doc = " the returned vector . this is important for the surrounding code, since for "] # [doc = " example, shifting the resulting vector right is equivalent to logically "] # [doc = " shifting the bytes in `slice` left ."] # [target feature (enable = " avx 2 ")] pub fn loadu 256 (slice : & [u 8] , at : usize) -> m 256 i { let ptr = slice . get unchecked (at ..) . as ptr () ; mm 256 loadu si 256 (ptr as * const u 8 as * const m 256 i) }
# [doc = " returns a 128-bit vector with all bits set to 1 ."] # [target feature (enable = " sse 2 ")] pub fn ones 128 () -> m 128 i { mm set 1 epi 8 (0 x ff as u 8 as i 8) }
# [doc = " returns a 256-bit vector with all bits set to 1 ."] # [target feature (enable = " avx 2 ")] pub fn ones 256 () -> m 256 i { mm 256 set 1 epi 8 (0 x ff as u 8 as i 8) }
# [doc = " unpack the given 128-bit vector into its 64-bit components . the first "] # [doc = " element of the array returned corresponds to the least significant 64-bit "] # [doc = " lane in `a`."] # [target feature (enable = " ssse 3 ")] pub fn unpack 64 x 128 (a : m 128 i) -> [u 64 ; 2] { [ mm cvtsi 128 si 64 (a) as u 64 , mm cvtsi 128 si 64 ( mm srli si 128 (a , 8)) as u 64 ,] }
# [doc = " unpack the given 256-bit vector into its 64-bit components . the first "] # [doc = " element of the array returned corresponds to the least significant 64-bit "] # [doc = " lane in `a`."] # [target feature (enable = " avx 2 ")] pub fn unpack 64 x 256 (a : m 256 i) -> [u 64 ; 4] { let lo = mm 256 extracti 128 si 256 (a , 0) ; let hi = mm 256 extracti 128 si 256 (a , 1) ; [ mm cvtsi 128 si 64 (lo) as u 64 , mm cvtsi 128 si 64 ( mm srli si 128 (lo , 8)) as u 64 , mm cvtsi 128 si 64 (hi) as u 64 , mm cvtsi 128 si 64 ( mm srli si 128 (hi , 8)) as u 64 ,] }
# [doc = " unpack the low 128-bits of `a` and `b`, and return them as 4 64-bit "] # [doc = " integers ."] # [doc = ""] # [doc = " more precisely, if a = a 4 a 3 a 2 a 1 and b = b 4 b 3 b 2 b 1, where each element "] # [doc = " is a 64-bit integer and a 1/b 1 correspond to the least significant 64 bits,"] # [doc = " then the return value is `b 2 b 1 a 2 a 1`."] # [target feature (enable = " avx 2 ")] pub fn unpacklo 64 x 256 (a : m 256 i , b : m 256 i) -> [u 64 ; 4] { let lo = mm 256 castsi 256 si 128 (a) ; let hi = mm 256 castsi 256 si 128 (b) ; [ mm cvtsi 128 si 64 (lo) as u 64 , mm cvtsi 128 si 64 ( mm srli si 128 (lo , 8)) as u 64 , mm cvtsi 128 si 64 (hi) as u 64 , mm cvtsi 128 si 64 ( mm srli si 128 (hi , 8)) as u 64 ,] }
# [doc = " returns a 128-bit vector with all bits set to 0 ."] # [target feature (enable = " sse 2 ")] pub fn zeroes 128 () -> m 128 i { mm set 1 epi 8 (0) }
# [doc = " returns a 256-bit vector with all bits set to 0 ."] # [target feature (enable = " avx 2 ")] pub fn zeroes 256 () -> m 256 i { mm 256 set 1 epi 8 (0) }
# [doc = " return a candidate for slim 128-bit teddy, where `chunk` corresponds to a "] # [doc = " 16-byte window of the haystack (where the least significant byte "] # [doc = " corresponds to the start of the window), and `mask 1` corresponds to a "] # [doc = " low/high mask for the first byte of all patterns that are being searched ."] # [target feature (enable = " ssse 3 ")] fn members 1 m 128 (chunk : m 128 i , mask 1 : mask 128) -> m 128 i { let lomask = mm set 1 epi 8 (0 x f) ; let hlo = mm and si 128 (chunk , lomask) ; let hhi = mm and si 128 ( mm srli epi 16 (chunk , 4) , lomask) ; mm and si 128 ( mm shuffle epi 8 (mask 1 . lo , hlo) , mm shuffle epi 8 (mask 1 . hi , hhi) ,) }
# [doc = " return a candidate for slim 256-bit teddy, where `chunk` corresponds to a "] # [doc = " 32-byte window of the haystack (where the least significant byte "] # [doc = " corresponds to the start of the window), and `mask 1` corresponds to a "] # [doc = " low/high mask for the first byte of all patterns that are being searched ."] # [doc = ""] # [doc = " note that this can also be used for fat teddy, where the high 128 bits in "] # [doc = " `chunk` is the same as the low 128 bits, which corresponds to a 16 byte "] # [doc = " window in the haystack ."] # [target feature (enable = " avx 2 ")] fn members 1 m 256 (chunk : m 256 i , mask 1 : mask 256) -> m 256 i { let lomask = mm 256 set 1 epi 8 (0 x f) ; let hlo = mm 256 and si 256 (chunk , lomask) ; let hhi = mm 256 and si 256 ( mm 256 srli epi 16 (chunk , 4) , lomask) ; mm 256 and si 256 ( mm 256 shuffle epi 8 (mask 1 . lo , hlo) , mm 256 shuffle epi 8 (mask 1 . hi , hhi) ,) }
# [doc = " return candidates for slim 128-bit teddy, where `chunk` corresponds "] # [doc = " to a 16-byte window of the haystack (where the least significant byte "] # [doc = " corresponds to the start of the window), and the masks correspond to a "] # [doc = " low/high mask for the first and second bytes of all patterns that are being "] # [doc = " searched . the vectors returned correspond to candidates for the first and "] # [doc = " second bytes in the patterns represented by the masks ."] # [target feature (enable = " ssse 3 ")] fn members 2 m 128 (chunk : m 128 i , mask 1 : mask 128 , mask 2 : mask 128 ,) -> ( m 128 i , m 128 i) { let lomask = mm set 1 epi 8 (0 x f) ; let hlo = mm and si 128 (chunk , lomask) ; let hhi = mm and si 128 ( mm srli epi 16 (chunk , 4) , lomask) ; let res 0 = mm and si 128 ( mm shuffle epi 8 (mask 1 . lo , hlo) , mm shuffle epi 8 (mask 1 . hi , hhi) ,) ; let res 1 = mm and si 128 ( mm shuffle epi 8 (mask 2 . lo , hlo) , mm shuffle epi 8 (mask 2 . hi , hhi) ,) ; (res 0 , res 1) }
# [doc = " return candidates for slim 256-bit teddy, where `chunk` corresponds "] # [doc = " to a 32-byte window of the haystack (where the least significant byte "] # [doc = " corresponds to the start of the window), and the masks correspond to a "] # [doc = " low/high mask for the first and second bytes of all patterns that are being "] # [doc = " searched . the vectors returned correspond to candidates for the first and "] # [doc = " second bytes in the patterns represented by the masks ."] # [doc = ""] # [doc = " note that this can also be used for fat teddy, where the high 128 bits in "] # [doc = " `chunk` is the same as the low 128 bits, which corresponds to a 16 byte "] # [doc = " window in the haystack ."] # [target feature (enable = " avx 2 ")] fn members 2 m 256 (chunk : m 256 i , mask 1 : mask 256 , mask 2 : mask 256 ,) -> ( m 256 i , m 256 i) { let lomask = mm 256 set 1 epi 8 (0 x f) ; let hlo = mm 256 and si 256 (chunk , lomask) ; let hhi = mm 256 and si 256 ( mm 256 srli epi 16 (chunk , 4) , lomask) ; let res 0 = mm 256 and si 256 ( mm 256 shuffle epi 8 (mask 1 . lo , hlo) , mm 256 shuffle epi 8 (mask 1 . hi , hhi) ,) ; let res 1 = mm 256 and si 256 ( mm 256 shuffle epi 8 (mask 2 . lo , hlo) , mm 256 shuffle epi 8 (mask 2 . hi , hhi) ,) ; (res 0 , res 1) }
# [doc = " return candidates for slim 128-bit teddy, where `chunk` corresponds "] # [doc = " to a 16-byte window of the haystack (where the least significant byte "] # [doc = " corresponds to the start of the window), and the masks correspond to a "] # [doc = " low/high mask for the first, second and third bytes of all patterns that "] # [doc = " are being searched . the vectors returned correspond to candidates for the "] # [doc = " first, second and third bytes in the patterns represented by the masks ."] # [target feature (enable = " ssse 3 ")] fn members 3 m 128 (chunk : m 128 i , mask 1 : mask 128 , mask 2 : mask 128 , mask 3 : mask 128 ,) -> ( m 128 i , m 128 i , m 128 i) { let lomask = mm set 1 epi 8 (0 x f) ; let hlo = mm and si 128 (chunk , lomask) ; let hhi = mm and si 128 ( mm srli epi 16 (chunk , 4) , lomask) ; let res 0 = mm and si 128 ( mm shuffle epi 8 (mask 1 . lo , hlo) , mm shuffle epi 8 (mask 1 . hi , hhi) ,) ; let res 1 = mm and si 128 ( mm shuffle epi 8 (mask 2 . lo , hlo) , mm shuffle epi 8 (mask 2 . hi , hhi) ,) ; let res 2 = mm and si 128 ( mm shuffle epi 8 (mask 3 . lo , hlo) , mm shuffle epi 8 (mask 3 . hi , hhi) ,) ; (res 0 , res 1 , res 2) }
# [doc = " return candidates for slim 256-bit teddy, where `chunk` corresponds "] # [doc = " to a 32-byte window of the haystack (where the least significant byte "] # [doc = " corresponds to the start of the window), and the masks correspond to a "] # [doc = " low/high mask for the first, second and third bytes of all patterns that "] # [doc = " are being searched . the vectors returned correspond to candidates for the "] # [doc = " first, second and third bytes in the patterns represented by the masks ."] # [doc = ""] # [doc = " note that this can also be used for fat teddy, where the high 128 bits in "] # [doc = " `chunk` is the same as the low 128 bits, which corresponds to a 16 byte "] # [doc = " window in the haystack ."] # [target feature (enable = " avx 2 ")] fn members 3 m 256 (chunk : m 256 i , mask 1 : mask 256 , mask 2 : mask 256 , mask 3 : mask 256 ,) -> ( m 256 i , m 256 i , m 256 i) { let lomask = mm 256 set 1 epi 8 (0 x f) ; let hlo = mm 256 and si 256 (chunk , lomask) ; let hhi = mm 256 and si 256 ( mm 256 srli epi 16 (chunk , 4) , lomask) ; let res 0 = mm 256 and si 256 ( mm 256 shuffle epi 8 (mask 1 . lo , hlo) , mm 256 shuffle epi 8 (mask 1 . hi , hhi) ,) ; let res 1 = mm 256 and si 256 ( mm 256 shuffle epi 8 (mask 2 . lo , hlo) , mm 256 shuffle epi 8 (mask 2 . hi , hhi) ,) ; let res 2 = mm 256 and si 256 ( mm 256 shuffle epi 8 (mask 3 . lo , hlo) , mm 256 shuffle epi 8 (mask 3 . hi , hhi) ,) ; (res 0 , res 1 , res 2) }

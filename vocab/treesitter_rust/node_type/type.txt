range_expression
where_predicate
scoped_use_list
function_modifiers
ref
trait
or_pattern
removed_trait_bound
-
const_item
break
extern_modifier
..=
match_expression
static_item
remaining_field_pattern
struct
base_field_initializer
bracketed_type
field_declaration_list
;
use_list
|=
boolean_literal
bounded_type
scoped_identifier
field_pattern
slice_pattern
use_declaration
type_identifier
tuple_pattern
loop_label
move
super
field_declaration
.
_literal_pattern
||
if_expression
trait_item
else_clause
macro_invocation
expr
static
+=
empty_statement
closure_parameters
float_literal
fn
unsafe
binary_expression
dynamic_type
pat
>>=
!=
return_expression
<<
generic_function
let
{
continue
!
tuple_struct_pattern
ref_pattern
variadic_parameter
enum_item
path
_declaration_statement
try_expression
use
meta_item
trait_bounds
|
macro_definition
function_signature_item
reference_expression
shorthand_field_initializer
parameter
use_as_clause
:
for_lifetimes
ordered_field_declaration_list
abstract_type
parenthesized_expression
tuple_type
extern_crate_declaration
$
crate
line_comment
->
<=
mod_item
while_expression
fragment_specifier
loop
parameters
_pattern
constrained_type_parameter
type
break_expression
in
impl
block
<
type_arguments
await_expression
_literal
array_expression
match_block
match
async_block
call_expression
macro_rule
default
enum
macro_rules!
metavariable
higher_ranked_trait_bound
impl_item
assignment_expression
reference_pattern
*
optional_type_parameter
@
field_identifier
closure_expression
primitive_type
pub
empty_type
self_parameter
use_wildcard
match_arm
token_repetition_pattern
while_let_expression
generic_type
field_initializer
type_item
=
struct_pattern
&&
while
meta_arguments
(
^
%=
enum_variant_list
/
%
type_cast_expression
stmt
where
where_clause
field_expression
pointer_type
match_pattern
"
type_parameters
extern
token_binding_pattern
if
scoped_type_identifier
type_binding
=>
for
#
+
captured_pattern
literal
unary_expression
qualified_type
[
let_declaration
range_pattern
const
-=
continue_expression
enum_variant
for_expression
false
mod
mutable_specifier
_expression
struct_item
await
_type
attribute_item
*=
tuple_expression
::
escape_sequence
ty
ident
foreign_mod_item
self
vis
<<=
identifier
union
,
unit_expression
)
shorthand_field_identifier
>>
loop_expression
unsafe_block
dyn
function_item
token_repetition
else
true
]
async
array_type
token_tree
function_type
generic_type_with_turbofish
declaration_list
visibility_modifier
raw_string_literal
lifetime
>=
...
struct_expression
?
==
/=
field_initializer_list
integer_literal
^=
mut_pattern
negative_literal
tt
arguments
string_literal
block_comment
source_file
return
const_parameter
char_literal
associated_type
&
union_item
&=
'
item
compound_assignment_expr
if_let_expression
..
meta
unit_type
inner_attribute_item
reference_type
as
token_tree_pattern
index_expression
}
>
_
error